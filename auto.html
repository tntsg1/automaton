<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>自动化殖民地 - 第一人称视角</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Segoe UI", "PingFang SC", sans-serif;
    }
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at 50% 10%, #1d2737 0%, #05070a 60%);
      color: #d2e0ff;
    }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      pointer-events: none;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      text-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
    }
    #toolbar {
      display: inline-flex;
      gap: 8px;
      pointer-events: auto;
    }
    #toolbar button {
      background: rgba(26, 40, 68, 0.85);
      color: #d2e0ff;
      border: 1px solid rgba(93, 145, 255, 0.4);
      border-radius: 4px;
      padding: 6px 12px;
      cursor: pointer;
      transition: background 0.2s, border 0.2s;
    }
    #toolbar button.active {
      background: rgba(79, 120, 255, 0.85);
      border-color: rgba(142, 192, 255, 0.9);
    }
    #toolbar button:hover {
      background: rgba(67, 97, 187, 0.85);
    }
    #hud {
      background: linear-gradient(135deg, rgba(10, 16, 28, 0.9), rgba(16, 24, 42, 0.6));
      backdrop-filter: blur(6px);
      padding: 12px 16px;
      border-radius: 8px;
      max-width: 360px;
      line-height: 1.5;
      pointer-events: auto;
    }
    #hud h2 {
      margin: 0 0 8px 0;
      font-size: 16px;
    }
    #hud .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 4px 10px;
      font-size: 13px;
    }
    #reticle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12px;
      height: 12px;
      margin: -6px 0 0 -6px;
      border: 2px solid rgba(200, 230, 255, 0.8);
      border-radius: 50%;
      pointer-events: none;
      mix-blend-mode: screen;
    }
    #log {
      max-height: 180px;
      overflow-y: auto;
      font-size: 12px;
      border-top: 1px solid rgba(90, 132, 211, 0.35);
      padding-top: 8px;
      margin-top: 8px;
    }
    #log p {
      margin: 0 0 4px 0;
      opacity: 0.9;
    }
    #hint {
      max-width: 300px;
      font-size: 13px;
      opacity: 0.85;
    }
    #lock-screen {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 50% 50%, rgba(45, 62, 109, 0.45), rgba(6, 9, 17, 0.92));
      color: #f0f4ff;
      font-size: 18px;
      text-align: center;
      padding: 32px;
      cursor: pointer;
      transition: opacity 0.3s;
      z-index: 10;
    }
    #lock-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="lock-screen">点击以进入殖民地控制界面<br>WASD移动，鼠标观察，空格跳跃，Shift冲刺</div>
  <div id="overlay">
    <div id="hint">
      鼠标左键放置建筑，右键拆除。按 R 从目标建筑或传送带收集物品。研究中心消耗科技包以解锁更高级的技术。
    </div>
    <div id="toolbar"></div>
    <div id="hud">
      <h2>殖民地状态</h2>
      <div class="grid" id="inventory"></div>
      <p>当前选择：<span id="selection">无</span></p>
      <p>研究进度：<span id="research">0%</span></p>
      <div id="log"></div>
    </div>
  </div>
  <div id="reticle"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js';
    import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/controls/PointerLockControls.js';

    const GRID_SIZE = 32;
    const TILE_SIZE = 4;
    const HALF = GRID_SIZE / 2;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x06080d);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 400);
    camera.position.set(0, 6, 12);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new PointerLockControls(camera, document.body);
    const lockScreen = document.getElementById('lock-screen');
    lockScreen.addEventListener('click', () => controls.lock());
    controls.addEventListener('lock', () => {
      lockScreen.classList.add('hidden');
    });
    controls.addEventListener('unlock', () => {
      lockScreen.classList.remove('hidden');
      highlight.visible = false;
    });

    const ambient = new THREE.AmbientLight(0x32405c, 0.7);
    scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xbfd4ff, 1.1);
    sun.position.set(40, 80, -20);
    sun.castShadow = true;
    sun.shadow.camera.near = 10;
    sun.shadow.camera.far = 200;
    sun.shadow.mapSize.set(2048, 2048);
    scene.add(sun);

    const groundGeo = new THREE.PlaneGeometry(GRID_SIZE * TILE_SIZE, GRID_SIZE * TILE_SIZE, GRID_SIZE, GRID_SIZE);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x1b273a,
      roughness: 0.85,
      metalness: 0.05,
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const gridHelper = new THREE.GridHelper(GRID_SIZE * TILE_SIZE, GRID_SIZE, 0x1d3356, 0x101a2d);
    gridHelper.position.y = 0.01;
    scene.add(gridHelper);

    const highlightGeo = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
    const highlightMat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent: true, opacity: 0.25, side: THREE.DoubleSide });
    const highlight = new THREE.Mesh(highlightGeo, highlightMat);
    highlight.rotation.x = -Math.PI / 2;
    highlight.position.y = 0.06;
    highlight.visible = false;
    scene.add(highlight);

    const worldToKey = (x, z) => `${x},${z}`;
    const structures = new Map();
    const resourceNodes = new Map();

    const playerInventory = {
      ironOre: 0,
      copperOre: 0,
      ironPlate: 20,
      copperPlate: 12,
      sciencePack: 0,
    };

    const itemNames = {
      ironOre: '铁矿石',
      copperOre: '铜矿石',
      ironPlate: '铁板',
      copperPlate: '铜板',
      sciencePack: '科技包',
    };

    const itemColors = {
      ironOre: 0x6c7dff,
      copperOre: 0xffb36a,
      ironPlate: 0xb0c6ff,
      copperPlate: 0xffe8b0,
      sciencePack: 0x9b6dff,
    };

    const buildCatalog = {
      belt: {
        name: '传送带',
        cost: { ironPlate: 1 },
        description: '将物品向前传送一格',
      },
      miner: {
        name: '采矿机',
        cost: { ironPlate: 8, copperPlate: 4 },
        description: '从矿脉中采集矿石',
      },
      smelter: {
        name: '熔炉',
        cost: { ironPlate: 12 },
        description: '将矿石冶炼为金属板',
      },
      assembler: {
        name: '自动工作台',
        cost: { ironPlate: 10, copperPlate: 6 },
        description: '将金属板合成为科技包',
      },
      lab: {
        name: '研究中心',
        cost: { ironPlate: 6, copperPlate: 6 },
        description: '消耗科技包研究新科技',
      },
      remove: {
        name: '拆除',
        cost: {},
        description: '拆除已有建筑，退还部分资源',
      }
    };

    const toolbar = document.getElementById('toolbar');
    const selectionLabel = document.getElementById('selection');
    let selectedBuild = 'belt';

    const logBox = document.getElementById('log');
    function pushLog(message) {
      const p = document.createElement('p');
      const time = new Date().toLocaleTimeString('zh-CN', { hour12: false });
      p.textContent = `[${time}] ${message}`;
      logBox.appendChild(p);
      if (logBox.children.length > 60) {
        logBox.removeChild(logBox.firstChild);
      }
      logBox.scrollTop = logBox.scrollHeight;
    }

    function updateToolbar() {
      toolbar.innerHTML = '';
      Object.entries(buildCatalog).forEach(([key, item]) => {
        const btn = document.createElement('button');
        btn.textContent = item.name;
        if (key === selectedBuild) btn.classList.add('active');
        btn.addEventListener('click', () => {
          selectedBuild = key;
          updateToolbar();
          selectionLabel.textContent = item.name;
          pushLog(`已选择：${item.name}`);
        });
        toolbar.appendChild(btn);
      });
      selectionLabel.textContent = buildCatalog[selectedBuild].name;
    }
    updateToolbar();

    const inventoryGrid = document.getElementById('inventory');
    function updateInventory() {
      inventoryGrid.innerHTML = '';
      Object.entries(playerInventory).forEach(([key, value]) => {
        if (value <= 0) return;
        const label = document.createElement('div');
        label.textContent = itemNames[key] ?? key;
        const val = document.createElement('div');
        val.textContent = value;
        inventoryGrid.append(label, val);
      });
    }
    updateInventory();

    const researchLabel = document.getElementById('research');
    const researchState = {
      progress: 0,
      goal: 120,
      tier: 1,
    };

    function updateResearchLabel() {
      const pct = Math.min(100, Math.floor((researchState.progress / researchState.goal) * 100));
      researchLabel.textContent = `${pct}%`;
    }
    updateResearchLabel();

    function keyToWorld(x, z) {
      return new THREE.Vector3(
        (x - HALF) * TILE_SIZE + TILE_SIZE / 2,
        0,
        (z - HALF) * TILE_SIZE + TILE_SIZE / 2
      );
    }

    function worldToGrid(point) {
      const localX = point.x / TILE_SIZE + HALF;
      const localZ = point.z / TILE_SIZE + HALF;
      const gx = Math.floor(localX);
      const gz = Math.floor(localZ);
      if (gx < 0 || gx >= GRID_SIZE || gz < 0 || gz >= GRID_SIZE) {
        return null;
      }
      return { x: gx, z: gz };
    }

    const directions = ['north', 'east', 'south', 'west'];
    const directionVectors = {
      north: { x: 0, z: -1, rotation: 0 },
      east: { x: 1, z: 0, rotation: Math.PI / 2 },
      south: { x: 0, z: 1, rotation: Math.PI },
      west: { x: -1, z: 0, rotation: -Math.PI / 2 },
    };

    function yawToDirection(yaw) {
      const normalized = (yaw + Math.PI * 2) % (Math.PI * 2);
      const index = Math.round(normalized / (Math.PI / 2)) % 4;
      return directions[index];
    }

    function getTileInDirection(tile, direction) {
      const vec = directionVectors[direction];
      return { x: tile.x + vec.x, z: tile.z + vec.z };
    }

    function createResourceNodes() {
      const resourceTypes = [
        { key: 'ironOre', color: 0x8ea6ff },
        { key: 'copperOre', color: 0xffa45b },
        { key: 'stone', color: 0xb7b9c7 },
      ];
      resourceTypes.forEach((res) => {
        for (let i = 0; i < 8; i++) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const z = Math.floor(Math.random() * GRID_SIZE);
          const key = worldToKey(x, z);
          if (resourceNodes.has(key)) continue;
          const worldPos = keyToWorld(x, z);
          const geo = new THREE.CylinderGeometry(1.1, 1.8, 1.6, 6);
          const mat = new THREE.MeshStandardMaterial({ color: res.color, emissive: 0x111b28, metalness: 0.15, roughness: 0.6 });
          const node = new THREE.Mesh(geo, mat);
          node.position.set(worldPos.x, 0.8, worldPos.z);
          node.castShadow = true;
          scene.add(node);
          resourceNodes.set(key, { type: res.key, mesh: node });
        }
      });
    }
    createResourceNodes();

    function canAfford(cost) {
      return Object.entries(cost).every(([key, amount]) => (playerInventory[key] ?? 0) >= amount);
    }

    function spendCost(cost) {
      Object.entries(cost).forEach(([key, amount]) => {
        playerInventory[key] = (playerInventory[key] ?? 0) - amount;
      });
    }

    function refundCost(cost) {
      Object.entries(cost).forEach(([key, amount]) => {
        playerInventory[key] = (playerInventory[key] ?? 0) + Math.ceil(amount * 0.5);
      });
    }

    const raycaster = new THREE.Raycaster();
    function findTargetTile() {
      if (!controls.isLocked) {
        highlight.visible = false;
        return null;
      }
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const intersects = raycaster.intersectObject(ground, false);
      if (intersects.length === 0) {
        highlight.visible = false;
        return null;
      }
      const tile = worldToGrid(intersects[0].point);
      if (!tile) {
        highlight.visible = false;
        return null;
      }
      const pos = keyToWorld(tile.x, tile.z);
      highlight.visible = true;
      highlight.position.set(pos.x, 0.06, pos.z);
      return tile;
    }

    function setBeltItem(belt, item) {
      if (belt.item === item) return;
      if (belt.cargoMesh) {
        scene.remove(belt.cargoMesh);
        belt.cargoMesh.geometry.dispose?.();
        belt.cargoMesh.material.dispose?.();
        belt.cargoMesh = null;
      }
      belt.item = item;
      if (item) {
        const geo = new THREE.BoxGeometry(0.9, 0.5, 0.9);
        const mat = new THREE.MeshStandardMaterial({ color: itemColors[item] ?? 0xffffff, emissive: 0x151c2e, roughness: 0.35, metalness: 0.3 });
        const cube = new THREE.Mesh(geo, mat);
        const worldPos = keyToWorld(belt.tile.x, belt.tile.z);
        cube.position.set(worldPos.x, 0.65, worldPos.z);
        cube.castShadow = true;
        belt.cargoMesh = cube;
        scene.add(cube);
      }
    }

    function addStructure(building) {
      const key = worldToKey(building.tile.x, building.tile.z);
      structures.set(key, building);
    }

    function removeStructure(tile) {
      const key = worldToKey(tile.x, tile.z);
      const existing = structures.get(key);
      if (!existing) return;
      if (existing.type === 'belt' && existing.cargoMesh) {
        scene.remove(existing.cargoMesh);
        existing.cargoMesh.geometry.dispose?.();
        existing.cargoMesh.material.dispose?.();
      }
      if (existing.type === 'miner' && existing.resourceKey) {
        const node = resourceNodes.get(existing.resourceKey);
        if (node) node.mesh.visible = true;
      }
      scene.remove(existing.mesh);
      if (existing.mesh.geometry) existing.mesh.geometry.dispose?.();
      if (existing.mesh.material) {
        const mat = existing.mesh.material;
        if (Array.isArray(mat)) mat.forEach((m) => m.dispose?.());
        else mat.dispose?.();
      }
      structures.delete(key);
      refundCost(existing.cost ?? {});
      updateInventory();
      pushLog(`拆除了${existing.name}`);
    }

    function tryPlaceStructure(tile) {
      const selected = buildCatalog[selectedBuild];
      if (!selected || selectedBuild === 'remove') return;
      const key = worldToKey(tile.x, tile.z);
      if (structures.has(key)) {
        pushLog('该位置已有建筑。');
        return;
      }
      if (!canAfford(selected.cost)) {
        pushLog('资源不足，无法建造。');
        return;
      }
      let building = null;
      const orientation = yawToDirection(camera.rotation.y);
      const worldPos = keyToWorld(tile.x, tile.z);

      if (selectedBuild === 'belt') {
        const geo = new THREE.BoxGeometry(TILE_SIZE * 0.9, 0.4, TILE_SIZE * 0.9);
        const mat = new THREE.MeshStandardMaterial({ color: 0x3a78ff, emissive: 0x0a1a3a, roughness: 0.4, metalness: 0.2 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(worldPos.x, 0.2, worldPos.z);
        mesh.rotation.y = directionVectors[orientation].rotation;
        mesh.castShadow = true;
        scene.add(mesh);
        building = {
          type: 'belt',
          name: '传送带',
          tile,
          mesh,
          direction: orientation,
          cost: selected.cost,
        };
        setBeltItem(building, null);
      } else if (selectedBuild === 'miner') {
        const node = resourceNodes.get(key);
        if (!node || (node.type !== 'ironOre' && node.type !== 'copperOre')) {
          pushLog('采矿机只能建在金属矿脉上。');
          return;
        }
        node.mesh.visible = false;
        const geo = new THREE.CylinderGeometry(1.2, 1.2, 2.2, 8);
        const mat = new THREE.MeshStandardMaterial({ color: 0x5ae3ff, emissive: 0x0f1f3d, roughness: 0.5, metalness: 0.6 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(worldPos.x, 1.1, worldPos.z);
        mesh.rotation.y = Math.random() * Math.PI;
        mesh.castShadow = true;
        scene.add(mesh);
        building = {
          type: 'miner',
          name: '采矿机',
          tile,
          mesh,
          direction: orientation,
          buffer: [],
          cooldown: 0,
          resource: node.type,
          resourceKey: key,
          cost: selected.cost,
        };
      } else if (selectedBuild === 'smelter') {
        const geo = new THREE.BoxGeometry(2.6, 2.2, 2.6);
        const mat = new THREE.MeshStandardMaterial({ color: 0xd96b43, emissive: 0x25130a, roughness: 0.5, metalness: 0.4 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(worldPos.x, 1.1, worldPos.z);
        mesh.rotation.y = directionVectors[orientation].rotation;
        mesh.castShadow = true;
        scene.add(mesh);
        building = {
          type: 'smelter',
          name: '熔炉',
          tile,
          mesh,
          direction: orientation,
          input: { ironOre: 0, copperOre: 0 },
          progress: 0,
          output: [],
          cost: selected.cost,
        };
      } else if (selectedBuild === 'assembler') {
        const geo = new THREE.BoxGeometry(3, 2, 3);
        const mat = new THREE.MeshStandardMaterial({ color: 0x60c47c, emissive: 0x122616, roughness: 0.35, metalness: 0.45 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(worldPos.x, 1.05, worldPos.z);
        mesh.rotation.y = directionVectors[orientation].rotation;
        mesh.castShadow = true;
        scene.add(mesh);
        building = {
          type: 'assembler',
          name: '自动工作台',
          tile,
          mesh,
          direction: orientation,
          input: { ironPlate: 0, copperPlate: 0 },
          progress: 0,
          output: [],
          cost: selected.cost,
        };
      } else if (selectedBuild === 'lab') {
        const geo = new THREE.CylinderGeometry(1.8, 1.8, 2.8, 12);
        const mat = new THREE.MeshStandardMaterial({ color: 0x7c82ff, emissive: 0x1b1c44, roughness: 0.3, metalness: 0.55 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(worldPos.x, 1.4, worldPos.z);
        mesh.rotation.y = directionVectors[orientation].rotation;
        mesh.castShadow = true;
        scene.add(mesh);
        building = {
          type: 'lab',
          name: '研究中心',
          tile,
          mesh,
          direction: orientation,
          science: 0,
          progress: 0,
          cost: selected.cost,
        };
      }

      if (building) {
        spendCost(selected.cost);
        addStructure(building);
        updateInventory();
        pushLog(`建造了${selected.name}`);
      }
    }

    function tryRemoveStructure(tile) {
      const key = worldToKey(tile.x, tile.z);
      const existing = structures.get(key);
      if (!existing) {
        pushLog('此处没有建筑。');
        return;
      }
      removeStructure(tile);
    }

    function tryCollect(tile) {
      const key = worldToKey(tile.x, tile.z);
      const existing = structures.get(key);
      if (!existing) return;
      if (existing.type === 'belt') {
        if (existing.item) {
          playerInventory[existing.item] = (playerInventory[existing.item] ?? 0) + 1;
          pushLog(`拾取了${existing.item}`);
          setBeltItem(existing, null);
          updateInventory();
        }
      } else if (existing.type === 'miner') {
        if (existing.buffer.length > 0) {
          const item = existing.buffer.shift();
          playerInventory[item] = (playerInventory[item] ?? 0) + 1;
          pushLog(`从采矿机收集了${item}`);
          updateInventory();
        }
      } else if (existing.type === 'smelter' || existing.type === 'assembler') {
        if (existing.output.length > 0) {
          const item = existing.output.shift();
          playerInventory[item] = (playerInventory[item] ?? 0) + 1;
          pushLog(`从${existing.name}收集了${item}`);
          updateInventory();
        }
      } else if (existing.type === 'lab') {
        const amount = Math.floor(existing.science);
        if (amount > 0) {
          playerInventory.sciencePack = (playerInventory.sciencePack ?? 0) + amount;
          pushLog(`收集了${amount}个科技包`);
          existing.science -= amount;
          updateInventory();
        }
      }
    }

    function acceptItem(building, item) {
      if (building.type === 'smelter') {
        if (item === 'ironOre' || item === 'copperOre') {
          if ((building.input[item] ?? 0) < 12) {
            building.input[item] = (building.input[item] ?? 0) + 1;
            return true;
          }
        }
      } else if (building.type === 'assembler') {
        if (item === 'ironPlate' || item === 'copperPlate') {
          if ((building.input[item] ?? 0) < 12) {
            building.input[item] = (building.input[item] ?? 0) + 1;
            return true;
          }
        }
      } else if (building.type === 'lab') {
        if (item === 'sciencePack') {
          building.science += 1;
          return true;
        }
      } else if (building.type === 'belt') {
        if (!building.item) {
          setBeltItem(building, item);
          return true;
        }
      }
      return false;
    }

    function deliverFromBuilding(building, item) {
      const targetTile = getTileInDirection(building.tile, building.direction);
      if (targetTile.x < 0 || targetTile.x >= GRID_SIZE || targetTile.z < 0 || targetTile.z >= GRID_SIZE) {
        return false;
      }
      const key = worldToKey(targetTile.x, targetTile.z);
      const receiver = structures.get(key);
      if (receiver && acceptItem(receiver, item)) {
        return true;
      }
      return false;
    }

    function updateMiner(miner, delta) {
      miner.cooldown -= delta;
      if (miner.cooldown <= 0) {
        if (miner.buffer.length < 4) {
          miner.buffer.push(miner.resource);
        }
        miner.cooldown = 4;
      }
      if (miner.buffer.length > 0) {
        const canDeliver = deliverFromBuilding(miner, miner.buffer[0]);
        if (canDeliver) {
          miner.buffer.shift();
        }
      }
    }

    function updateSmelter(smelter, delta) {
      const totalOre = smelter.input.ironOre + smelter.input.copperOre;
      if (totalOre > 0) {
        smelter.progress += delta;
        if (smelter.progress >= 6) {
          let product = null;
          if (smelter.input.ironOre > 0) {
            smelter.input.ironOre -= 1;
            product = 'ironPlate';
          } else if (smelter.input.copperOre > 0) {
            smelter.input.copperOre -= 1;
            product = 'copperPlate';
          }
          if (product) {
            smelter.output.push(product);
            pushLog(`熔炉完成：${product}`);
          }
          smelter.progress = 0;
        }
      } else {
        smelter.progress = 0;
      }
      if (smelter.output.length > 0) {
        const delivered = deliverFromBuilding(smelter, smelter.output[0]);
        if (delivered) smelter.output.shift();
      }
    }

    function updateAssembler(assembler, delta) {
      if (assembler.input.ironPlate > 0 && assembler.input.copperPlate > 0) {
        assembler.progress += delta;
        if (assembler.progress >= 8) {
          assembler.input.ironPlate -= 1;
          assembler.input.copperPlate -= 1;
          assembler.output.push('sciencePack');
          assembler.progress = 0;
          pushLog('自动工作台产出科技包');
        }
      } else {
        assembler.progress = 0;
      }
      if (assembler.output.length > 0) {
        const delivered = deliverFromBuilding(assembler, assembler.output[0]);
        if (delivered) assembler.output.shift();
      }
    }

    function updateLab(lab, delta) {
      if (lab.science >= 1) {
        lab.progress += delta;
        if (lab.progress >= 4) {
          lab.progress = 0;
          lab.science -= 1;
          researchState.progress += 1;
          if (researchState.progress >= researchState.goal) {
            researchState.progress = 0;
            researchState.goal = Math.floor(researchState.goal * 1.4);
            researchState.tier += 1;
            pushLog(`研究完成！解锁第${researchState.tier}级科技。`);
          }
          updateResearchLabel();
        }
      } else {
        lab.progress = 0;
      }
    }

    function moveBelts(delta) {
      const intents = [];
      structures.forEach((structure) => {
        if (structure.type !== 'belt') return;
        if (!structure.item) return;
        const targetTile = getTileInDirection(structure.tile, structure.direction);
        if (targetTile.x < 0 || targetTile.x >= GRID_SIZE || targetTile.z < 0 || targetTile.z >= GRID_SIZE) {
          return;
        }
        const targetKey = worldToKey(targetTile.x, targetTile.z);
        const target = structures.get(targetKey);
        if (!target) return;
        intents.push({ from: structure, to: target, item: structure.item });
      });
      intents.forEach((intent) => {
        const { from, to, item } = intent;
        if (from.item !== item) return;
        if (to.type === 'belt') {
          if (!to.item) {
            setBeltItem(to, item);
            setBeltItem(from, null);
          }
        } else if (to.type !== 'belt') {
          if (acceptItem(to, item)) {
            setBeltItem(from, null);
          }
        }
      });
    }

    let prevTime = performance.now();
    function tick() {
      const now = performance.now();
      const delta = (now - prevTime) / 1000;
      prevTime = now;
      structures.forEach((structure) => {
        switch (structure.type) {
          case 'miner':
            updateMiner(structure, delta);
            break;
          case 'smelter':
            updateSmelter(structure, delta);
            break;
          case 'assembler':
            updateAssembler(structure, delta);
            break;
          case 'lab':
            updateLab(structure, delta);
            break;
        }
      });
      moveBelts(delta);
      findTargetTile();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    const velocity = new THREE.Vector3();
    const directionVec = new THREE.Vector3();
    const moveState = { forward: false, backward: false, left: false, right: false, jump: false };
    const speed = { walk: 18, sprint: 32 };
    let canJump = false;

    function onKeyDown(event) {
      switch (event.code) {
        case 'KeyW': moveState.forward = true; break;
        case 'KeyS': moveState.backward = true; break;
        case 'KeyA': moveState.left = true; break;
        case 'KeyD': moveState.right = true; break;
        case 'Space': if (canJump) { velocity.y += 15; canJump = false; } break;
        case 'ShiftLeft': moveState.sprint = true; break;
        case 'Digit1': selectedBuild = 'belt'; updateToolbar(); break;
        case 'Digit2': selectedBuild = 'miner'; updateToolbar(); break;
        case 'Digit3': selectedBuild = 'smelter'; updateToolbar(); break;
        case 'Digit4': selectedBuild = 'assembler'; updateToolbar(); break;
        case 'Digit5': selectedBuild = 'lab'; updateToolbar(); break;
        case 'Digit6': selectedBuild = 'remove'; updateToolbar(); break;
        case 'KeyR': {
          const tile = findTargetTile();
          if (tile) tryCollect(tile);
        } break;
      }
    }

    function onKeyUp(event) {
      switch (event.code) {
        case 'KeyW': moveState.forward = false; break;
        case 'KeyS': moveState.backward = false; break;
        case 'KeyA': moveState.left = false; break;
        case 'KeyD': moveState.right = false; break;
        case 'ShiftLeft': moveState.sprint = false; break;
      }
    }

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    const clock = new THREE.Clock();
    function updateMovement() {
      const delta = clock.getDelta();
      if (!controls.isLocked) return requestAnimationFrame(updateMovement);

      velocity.x -= velocity.x * 8 * delta;
      velocity.z -= velocity.z * 8 * delta;
      velocity.y -= 25 * delta;

      directionVec.z = Number(moveState.forward) - Number(moveState.backward);
      directionVec.x = Number(moveState.right) - Number(moveState.left);
      directionVec.normalize();

      const currentSpeed = moveState.sprint ? speed.sprint : speed.walk;
      if (moveState.forward || moveState.backward) velocity.z -= directionVec.z * currentSpeed * delta;
      if (moveState.left || moveState.right) velocity.x -= directionVec.x * currentSpeed * delta;

      controls.moveRight(-velocity.x * delta);
      controls.moveForward(-velocity.z * delta);
      camera.position.y += velocity.y * delta;
      if (camera.position.y < 3) {
        velocity.y = 0;
        camera.position.y = 3;
        canJump = true;
      }

      requestAnimationFrame(updateMovement);
    }
    requestAnimationFrame(updateMovement);

    function onMouseDown(event) {
      if (!controls.isLocked) return;
      const tile = findTargetTile();
      if (!tile) return;
      if (event.button === 0) {
        if (selectedBuild === 'remove') {
          tryRemoveStructure(tile);
        } else {
          tryPlaceStructure(tile);
        }
      } else if (event.button === 2) {
        tryRemoveStructure(tile);
      }
    }

    document.addEventListener('contextmenu', (e) => e.preventDefault());
    document.addEventListener('mousedown', onMouseDown);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    pushLog('欢迎来到戴森球计划式第一人称殖民地。建造采矿机、传送带与熔炉以处理矿石。');
    pushLog('自动工作台需要铁板和铜板才能产出科技包，研究中心消耗科技包推进科技。');
  </script>
</body>
</html>
